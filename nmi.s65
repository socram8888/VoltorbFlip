
; ***************
; * NMI HANDLER *
; ***************
nmi_handler:
	; Save registers
	pha
	txa
	pha
	tya
	pha

	; Increment frame counter
	inc framectr

	; Reset PPU address and VBlank flag
	lda PPUSTATUS

	; Enable/disable PPU rendering
	lda maskval
	sta PPUMASK

	; *****************
	; * Load PPU data *
	; *****************
	;
	; This is an implementation of the PPU buffer explained in "The frame
	; and NMIs" by Disch
	;
	; Page 3 ($0300-$03FF) is used as a circular buffer, with the main thread
	; writing (using ppubufpos as index) and the NMI thread reading (using
	; nmippubufpos as index)
	;
	; Each entry is formed by:
	;  - Byte 0: flags. Must be non-zero (use any non-flag bit, such as bit 0)
	;    - Bit 7: if set, data is copied from RLE-compressed ROM, otherwise RAM
	;    - Bit 2: if set, increment is 32 (vertical), otherwise 1 (horizontal)
	;  - Byte 1: higher address nibble
	;  - Byte 2: lower address nibble
	; If copying from RAM:
	;  - Byte 3: length
	;  - Byte 4...n: data
	; If copying from ROM:
	;  - Byte 3: source address MSB
	;  - Byte 4: source address LSB
@nextppuload:
	ldy nmippubufpos

@nextppu:
	; Load flags, quit if zero
	ldx $300,Y
	beq @ppubufend
	iny

	; Set increment now
	txa
	and #$04
	sta PPUCTRL

	; Set PPU load address
	lda $300,Y
	iny
	sta PPUADDR
	lda $300,Y
	iny
	sta PPUADDR

	; Check copy source
	txa
	bmi @fromrom

	; Copy from RAM - load count then copy
	ldx $300,Y
	iny

-	lda $300,Y
	sta PPUDATA
	iny
	dex
	bne -

	jmp @nextppu

@fromrom:
	; Load ROM address and prepare it for indirect-indirect addressing
	lda $300,Y
	iny
	sta nmiind+1
	lda $300,Y
	iny
	sta nmiind+0

	sty nmippubufpos
	ldy #0

	; RLE compression is based on GBA RLUnComp, as seen on NESdev
	; https://wiki.nesdev.com/w/index.php/Tile_compression#GBA_RLUnComp
	;
	; Value | Description
	;  00   | End of stream
	; 01-7F | Copy next n bytes to PPU
	; 80-FF | Repeat the next byte n-126 times
@nextrleblock:
	lax_izy nmiind
	beq @nextppuload
	bmi @rlerepeated

	; If 01-7F, copy "n" bytes
	iny
-	lda (nmiind),Y
	iny
	sta PPUDATA
	dex
	bne -
	jmp @nextrleblock

@rlerepeated:
	iny

	; Substract 126 to X
	; "tax" before "axs" is skipped because "lax" above already made A = X
	axs #126

	; Now copy n - 126 the next read byte
	lda (nmiind),Y
	iny
-	sta PPUDATA
	dex
	bne -
	jmp @nextrleblock

@ppubufend:
	sty nmippubufpos

	; ***********
	; * Sprites *
	; ***********

	; Update sprite data if needed
	lda updateoam
	beq +
	lda #0
	sta updateoam
	sta OAMADDR
	lda #2
	sta OAMDMA
+:

	; ***************
	; * Controllers *
	; ***************

	; Read controllers using NESdev ring trick
	ldx #1
	stx joy2pressed

	; Strobe shift register
	stx JOY1
	dex
	stx JOY1

	; Read controllers
-	lda JOY1
	lsr A
	rol joy1pressed
	lda JOY2
	lsr A
	rol joy2pressed
	bcc -

	; *************
	; * Scrolling *
	; *************

	; We must check if the scroll position has been completely updated to avoid graphical glitches
	lda setscroll
	beq @uselastscroll
	lda #0
	sta setscroll

	; Update scroll, and save for later frames
	lda scrollx
	sta lastscrollx
	sta PPUSCROLL
	lda scrolly
	sta lastscrolly
	sta PPUSCROLL
	jmp @updatedscroll

	; Write last good known scroll position
	; Must be after the last write to PPUADDR due to hardware errata
@uselastscroll:
	lda lastscrollx
	sta PPUSCROLL
	lda lastscrolly
	sta PPUSCROLL
@updatedscroll:

	; Re-enable NMI interruptions
	lda #$80
	sta PPUCTRL

	; Restore and return
	pla
	tay
	pla
	tax
	pla
	rti
